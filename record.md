# record

> 记录自己leetcode刷题经历

## 2020.09.21

##### 47 全排列

重新做了47题，已经完全不会做了，这遍又是看了题解才能解出
复杂度实现为O(n*n!)
能够想出通过回溯的方法得到全排列，但是因为有了重复数字，如何进行判重是一个很难搞的事

```
if (vis[i] || (i > 0 && nums[i-1] == nums[i] && !vis[i-1])) continue
```

##### 201  对[m, n]区间的数字取并

暴力取并会超时，自己也发现了数学上的规律：从高位到低位，当某一位数字不相同时，后续取并均为0
自己实现是借用了stl中的bitset数据结构，转化为bitset后，再寻找到一个不相同的数字
看了题解发现，问题可以更普适的归纳为寻找两个数字的公共前缀，当m/n不等时，不断右移，记录移动位数，再将公共前缀左移相应位数可以得到答案

##### 229 摩尔投票法
通过map记录每人票数方法不符合O(1)空间复杂度要求
使用通用的摩尔投票法，可以使用O(1)空间解决问题

```
如果至多选m个代表，那他们的票数至少要超过 ⌊ 1/(m+1) ⌋ 的票数
```




## 2020.09.20

##### 228 汇总区间

题目很简单，需要捋清逻辑和转折关系




## 2020.10.01

##### 1011 在D天内送达包裹的能力

最大最小问题
$$min{max{area1, area2, ..., area_n}}(n < D)$$
自己最开始是一种优化后的搜索（=枚举=暴力），然后不出意外的超时了
穆大哥讲了最大最小问题的通用思路**二分**
将一个求解问题转化为已知结果的判定问题
首先可以将外层的min或max去除，然后将内层的min或max可以比较容易的判定得到结果




## 2020.10.02

##### 1028 从先序遍历还原二叉树

感觉这个题是自己最不喜欢做的字符串问题，最大的难点在于下标的记录
因为需要不断读出当前的深度与数字，所以如果发现读错了的话，就需要回退到之前的位置，并尝试构建上一层的树节点
自己用了引用，感觉也是比较必要的，因为c++只能返回一个参数

##### 1029 两地调度

理解好问题就还算简单，假设所有人都去A地，那么想办法省点钱，就是让那些转去B地能省出更多的钱的人转去B地

##### 1030 距离顺序排列矩阵单元格

bfs 宽度遍历

##### 916 单词子集

学会简化问题，抓住问题本质
