# record

> 记录自己leetcode刷题经历

## 2020.09.21

### 47 全排列

重新做了47题，已经完全不会做了，这遍又是看了题解才能解出
复杂度实现为O(n*n!)
能够想出通过回溯的方法得到全排列，但是因为有了重复数字，如何进行判重是一个很难搞的事

```
if (vis[i] || (i > 0 && nums[i-1] == nums[i] && !vis[i-1])) continue
```

### 201  对[m, n]区间的数字取并

暴力取并会超时，自己也发现了数学上的规律：从高位到低位，当某一位数字不相同时，后续取并均为0
自己实现是借用了stl中的bitset数据结构，转化为bitset后，再寻找到一个不相同的数字
看了题解发现，问题可以更普适的归纳为寻找两个数字的公共前缀，当m/n不等时，不断右移，记录移动位数，再将公共前缀左移相应位数可以得到答案

### 229 摩尔投票法
通过map记录每人票数方法不符合O(1)空间复杂度要求
使用通用的摩尔投票法，可以使用O(1)空间解决问题

```
如果至多选m个代表，那他们的票数至少要超过 ⌊ 1/(m+1) ⌋ 的票数
```


## 2020.09.20

### 228 汇总区间

题目很简单，需要捋清逻辑和转折关系

## 2020.10.01

### 1011 在D天内送达包裹的能力

最大最小问题
min{max{area1, area2, ..., area_n}}(n < D)
自己最开始是一种优化后的搜索（=枚举=暴力），然后不出意外的超时了
穆大哥讲了最大最小问题的通用思路**二分**
将一个求解问题转化为已知结果的判定问题
首先可以将外层的min或max去除，然后将内层的min或max可以比较容易的判定得到结果
