# record

> 记录自己leetcode刷题经历

## 2020.08.01

##### 174. 地下城游戏

本来最开始觉得是一道比较简单的先向右再向下的动态规划题,然后后来发现，如果采用正常的动态规划的方法，有两个量需要记录，一个是维持存活的最小值，一个是路径和
位置存活的最小值要尽可能的小,路径和要尽可能的大,然后这俩是同等重要的，所以无法进行状态转移，也就是官方题解中提到的，没有后效性
当逆向进行考虑时，发现是不需要记录路径和的，

```
dp[i][j] = max(min(dp[i][j+1], dp[i+1][j]) - dungeon[i][j], 1)
```

##### 384. 打乱数组
这个题最开始通过的方法是直接调用了random.shuffle, 这样做实际上不行的，这个题中涉及到的是洗牌算法
法1：暴力,将待shuffle的array复制

##### 43. 大整数乘法

1. 使用python可以直接进行大整数计算，但是进行字符串转换为整数类型时是行不通的
2. 选择了使用c++，其实使用python进行字符串处理和数组操作是更方便一点的
3. 思路：
	1. 将待乘的整数转换为逆序
	2. 开辟好保存结果的数组，长度初始设置为len(num1) + len(num2), 初始化为0
	3. 仿照乘法竖式计算，只是计算过程中没有进行进位，将结果保留到res数组中
	4. 完成第3步后，结果数组中的每个元素可能是不满足处于0-9之间的，需要捋一遍满足进制
	5. 最后去除前导零

##### 47. 数组打乱
这个题从昨天开始做，昨天最后没有做出来

最开始能够想到，想要避免重复有两种思路，一种是最开始就进行减枝，一种是完成后进行去重，发现去重需要的时间复杂度过大
在计算过程中进行减枝的方法，自己想到的是是与已有结果中进行比较，最终是超时的，现在想了一下，好像如果这样做的话，最后的效率和完全完成后去重效率是一样的
<br>
根据题解学习到的方法，是需要观察遍历的过程，得到减枝条件
```
used[i] || (i>0 && nums[i] == nums[i-1] && !used[i])
```
绝了，真的精妙，最开始都没能理解，也意识到了自己的思考问题的情绪度真的有差劲诶

##### 49. 字母异位词分组
hash表，其实就是dict, 感觉说成hashtable真的高大上诶,学了一点c++ map的用法,也体会到了c++ iterator的精妙,比如对一个string,想要按字母序排序的话，就可以直接sort(str.begin(), str.end())了，也意识到了很多c++函数自己都没有掌握

##### 1340. 跳跃游戏V
真的感觉有点难
虽然最后抄的官方的代码，看上去很简单，但是这个思想真的还是挺重要的
自己想出来了有两种存储数据的方法
1. 在每个节点上存储以该节点为起始节点，所能达到的最大深度
2. 是在每个节点上存储到达已该节点为底的最大深度
自己实现了第二种方法，但是时间复杂度不够，超时很多现在想了一下，感觉确实第二种方法更像是一种模拟，第一种方法更容易达到拆分子问题的方式.学到了记忆化搜索的思路，这个以后应该会经常用到




## 2020.08.02
632/114/60/180/181/182/183/184/196: 自连接, delete




## 2020.08.03
197/415/595/596/70




## 2020.08.04
207/210/62/626/1038/1382




## 2020.08.05
337/17.12/74/71




## 2020.08.07
100/61/66



## 2020.09.21

##### 47 全排列
重新做了47题，已经完全不会做了，这遍又是看了题解才能解出
复杂度实现为O(n*n!)
能够想出通过回溯的方法得到全排列，但是因为有了重复数字，如何进行判重是一个很难搞的事

```
if (vis[i] || (i > 0 && nums[i-1] == nums[i] && !vis[i-1])) continue
```

##### 201  对[m, n]区间的数字取并
暴力取并会超时，自己也发现了数学上的规律：从高位到低位，当某一位数字不相同时，后续取并均为0
自己实现是借用了stl中的bitset数据结构，转化为bitset后，再寻找到一个不相同的数字
看了题解发现，问题可以更普适的归纳为寻找两个数字的公共前缀，当m/n不等时，不断右移，记录移动位数，再将公共前缀左移相应位数可以得到答案

##### 229 摩尔投票法
通过map记录每人票数方法不符合O(1)空间复杂度要求
使用通用的摩尔投票法，可以使用O(1)空间解决问题

```
如果至多选m个代表，那他们的票数至少要超过 ⌊ 1/(m+1) ⌋ 的票数
```


## 2020.09.20
##### 228 汇总区间
题目很简单，需要捋清逻辑和转折关系




## 2020.10.01
##### 1011 在D天内送达包裹的能力
最大最小问题 $min{max{area1, area2, ..., area_n}}(n 小于 D)$
自己最开始是一种优化后的搜索（=枚举=暴力），然后不出意外的超时了
穆大哥讲了最大最小问题的通用思路**二分**
将一个求解问题转化为已知结果的判定问题
首先可以将外层的min或max去除，然后将内层的min或max可以比较容易的判定得到结果




## 2020.10.02
##### 1028 从先序遍历还原二叉树
感觉这个题是自己最不喜欢做的字符串问题，最大的难点在于下标的记录
因为需要不断读出当前的深度与数字，所以如果发现读错了的话，就需要回退到之前的位置，并尝试构建上一层的树节点
自己用了引用，感觉也是比较必要的，因为c++只能返回一个参数

##### 1029 两地调度
理解好问题就还算简单，假设所有人都去A地，那么想办法省点钱，就是让那些转去B地能省出更多的钱的人转去B地

##### 1030 距离顺序排列矩阵单元格
bfs 宽度遍历

##### 916 单词子集
学会简化问题，抓住问题本质




## 2020.10.03
##### 105 从前序和中序恢复二叉树
本来想用更简洁的方法，传递空指针进到build函数中再构建，但是发现这样会出现问题
只能先构造根节点，再进入构造函数，构造left和right子节点

##### 106 从中序和后序恢复二叉树
思路和上题是一模一样的，两题均需注意的是下标的选取，感觉4个下标还是很烦的

##### 112 路径总和
遍历二叉树就可以了

##### 113 路径总和II
遍历二叉树+回溯

##### 115 不同的子序列(TODO)
这个题最开始理解题意有些问题，想的有点简单了
后来只想出了最简单的模拟方法，但是非常轻松的就超时了
自己并没有想出来真正的解决方法
看了题解发现可以使用动态规划进行解决
dp[i][j] 数组表示，对于T字符串中的前i个字符，使用S字符串中的前j个字符，可以有多少个子序列符合条件
转移方程为：
1. 当t[i-1]==s[j-1]: dp[i][j] = dp[i-1][j-1] + dp[i][j-1]
2. 当t[i-1]!=s[j-1]: dp[i][j] = dp[i][j-1]

对于i=0时，dp[0][j] = 1
对于j=0时，dp[i][0] = 0

##### 116 填充每个节点的下一个右侧节点指针
自己写出了时间复杂度O(N) 空间复杂度O(N)的算法，就是最简单的BFS，使用了双层stack，按理应该使用queue，先进先出的更加科学
进阶要求为空间复杂度常数，其实也是可以做到的，分为同父母节点连接next，异父母节点连接next
贴一个自己觉得比较好的代码
```
class Solution {
public:
    void dfs116Combine(Node* root, Node* parent) {
        if (root->left) {
            dfs116Combine(root->left, root);
        }
        if (parent) {//跳过根节点
            if (parent->right != root) {//同父母节点的next
                root->next = parent->right;
            }
            else if(parent->next){//异父母节点的next
                root->next = parent->next->left;
            }
            else {//137这些边缘节点的next
                root->next = nullptr;
            }
        }
        if (root->right) {
            dfs116Combine(root->right, root);
        }
    }
    Node* connect(Node* root) {
        if (root == nullptr) return root;
        dfs116Combine(root, nullptr);
        return root;
    }
};

```

##### 117. 填充每个节点的下一个右侧节点指针 II
这个题相较于上一个题，因为树不再是完全二叉树了，所以寻找next变得稍显困难
1. 自己是在116看到的题解，也就是上述代码的基础上进行修改的，最开始陷入了思维误区，就是需要一直向上遍历，再向下寻找才能找到下一个异父节点，但因为我们对上一层已经构建了next链条，所以直接在上一层进行横向遍历就好了
2. 构建的顺序问题，首先要将本层打通，其次因为我们的链条是从左指向右，所以需要先将右边构建好，再构建左边

##### 124. 二叉树中的最大路径和
最后写出来的代码会发现很短，自己一开始的模糊思路还是比较复杂的，但是写着写着会逐渐简化
怎样去清晰定义答案和划分成子问题比较关键，感觉思考的过程可以再锻炼下
具体到题目本身，可以简化为几个定义：
一个完整路径组成：最高节点+两个分支各自的子分支最大值
一个子分支最大值：0 或 由分支节点组成的分支最大值
一个分支的最大值：最高节点+一个分支的子分支最大值

##### 125. 验证回文串
一个扩展版的验证回文串，需要处理一下下标和待比对的字符





## 2020.10.04
##### 143. 重排链表
链表操作题，感觉对指针的值是一个地址这个概念更加理解了

##### 139. 单词拆分
动态规划+记忆化搜索
自己最开始用的是暴力模拟，然后就超时了，（TODO）这个还真不会
看了题解，学习到了记忆化搜索，做到了时间复杂度为O(n^2)，定义dp[i]数组为从头开始，长度为i的字串是否能够被解决
然后可以通过前面是否被解决，推导出新的位置是否被解决，方法为遍历从前面的某个下标开始，到当前位置结束的字串是否在给定的单词列表中，以及那个下标是否被解决

##### 5531
周赛题目

##### 5532
周赛题目

##### 5534
周赛题目
最后没有做出来，涉及到几何问题，最后自己卡在了现有方法的精度问题上





## 2020.10.05
##### 145. 二叉树的后序遍历
自己通过vector<TreeNode*> 模拟stack，和set<TreeNode*>记录是否被扩展搜索过连个数据结构组合完成了题目

##### 147. 对链表进行插入排序
自己实现的是新开一个链表，进行排序，每次都是从前向后比较，开销会有点大


