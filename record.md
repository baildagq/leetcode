# record

> 记录自己leetcode刷题经历

## 2020.09.21

##### 47 全排列

重新做了47题，已经完全不会做了，这遍又是看了题解才能解出
复杂度实现为O(n*n!)
能够想出通过回溯的方法得到全排列，但是因为有了重复数字，如何进行判重是一个很难搞的事

```
if (vis[i] || (i > 0 && nums[i-1] == nums[i] && !vis[i-1])) continue
```

##### 201  对[m, n]区间的数字取并

暴力取并会超时，自己也发现了数学上的规律：从高位到低位，当某一位数字不相同时，后续取并均为0
自己实现是借用了stl中的bitset数据结构，转化为bitset后，再寻找到一个不相同的数字
看了题解发现，问题可以更普适的归纳为寻找两个数字的公共前缀，当m/n不等时，不断右移，记录移动位数，再将公共前缀左移相应位数可以得到答案

##### 229 摩尔投票法
通过map记录每人票数方法不符合O(1)空间复杂度要求
使用通用的摩尔投票法，可以使用O(1)空间解决问题

```
如果至多选m个代表，那他们的票数至少要超过 ⌊ 1/(m+1) ⌋ 的票数
```




## 2020.09.20

##### 228 汇总区间

题目很简单，需要捋清逻辑和转折关系




## 2020.10.01

##### 1011 在D天内送达包裹的能力

最大最小问题
$$min{max{area1, area2, ..., area_n}}(n < D)$$
自己最开始是一种优化后的搜索（=枚举=暴力），然后不出意外的超时了
穆大哥讲了最大最小问题的通用思路**二分**
将一个求解问题转化为已知结果的判定问题
首先可以将外层的min或max去除，然后将内层的min或max可以比较容易的判定得到结果




## 2020.10.02

##### 1028 从先序遍历还原二叉树

感觉这个题是自己最不喜欢做的字符串问题，最大的难点在于下标的记录
因为需要不断读出当前的深度与数字，所以如果发现读错了的话，就需要回退到之前的位置，并尝试构建上一层的树节点
自己用了引用，感觉也是比较必要的，因为c++只能返回一个参数

##### 1029 两地调度

理解好问题就还算简单，假设所有人都去A地，那么想办法省点钱，就是让那些转去B地能省出更多的钱的人转去B地

##### 1030 距离顺序排列矩阵单元格

bfs 宽度遍历

##### 916 单词子集

学会简化问题，抓住问题本质

## 2020.10.03

##### 105 从前序和中序恢复二叉树

本来想用更简洁的方法，传递空指针进到build函数中再构建，但是发现这样会出现问题
只能先构造根节点，再进入构造函数，构造left和right子节点

##### 106 从中序和后序恢复二叉树

思路和上题是一模一样的，两题均需注意的是下标的选取，感觉4个下标还是很烦的

##### 112 路径总和
遍历二叉树就可以了

##### 113 路径总和II
遍历二叉树+回溯

##### 115 不同的子序列(TODO)
这个题最开始理解题意有些问题，想的有点简单了
后来只想出了最简单的模拟方法，但是非常轻松的就超时了
自己并没有想出来真正的解决方法
看了题解发现可以使用动态规划进行解决
dp[i][j] 数组表示，对于T字符串中的前i个字符，使用S字符串中的前j个字符，可以有多少个子序列符合条件
转移方程为：
1. 当t[i-1]==s[j-1]: dp[i][j] = dp[i-1][j-1] + dp[i][j-1]
2. 当t[i-1]!=s[j-1]: dp[i][j] = dp[i][j-1]

对于i=0时，dp[0][j] = 1
对于j=0时，dp[i][0] = 0

##### 116 填充每个节点的下一个右侧节点指针
自己写出了时间复杂度O(N) 空间复杂度O(N)的算法，就是最简单的BFS，使用了双层stack，按理应该使用queue，先进先出的更加科学
进阶要求为空间复杂度常数，其实也是可以做到的，分为同父母节点连接next，异父母节点连接next
贴一个自己觉得比较好的代码
```
class Solution {
public:
    void dfs116Combine(Node* root, Node* parent) {
        if (root->left) {
            dfs116Combine(root->left, root);
        }
        if (parent) {//跳过根节点
            if (parent->right != root) {//同父母节点的next
                root->next = parent->right;
            }
            else if(parent->next){//异父母节点的next
                root->next = parent->next->left;
            }
            else {//137这些边缘节点的next
                root->next = nullptr;
            }
        }
        if (root->right) {
            dfs116Combine(root->right, root);
        }
    }
    Node* connect(Node* root) {
        if (root == nullptr) return root;
        dfs116Combine(root, nullptr);
        return root;
    }
};

```

##### 117. 填充每个节点的下一个右侧节点指针 II
这个题相较于上一个题，因为树不再是完全二叉树了，所以寻找next变得稍显困难
1. 自己是在116看到的题解，也就是上述代码的基础上进行修改的，最开始陷入了思维误区，就是需要一直向上遍历，再向下寻找才能找到下一个异父节点，但因为我们对上一层已经构建了next链条，所以直接在上一层进行横向遍历就好了
2. 构建的顺序问题，首先要将本层打通，其次因为我们的链条是从左指向右，所以需要先将右边构建好，再构建左边

##### 124. 二叉树中的最大路径和

最后写出来的代码会发现很短，自己一开始的模糊思路还是比较复杂的，但是写着写着会逐渐简化
怎样去清晰定义答案和划分成子问题比较关键，感觉思考的过程可以再锻炼下

具体到题目本身，可以简化为几个定义：
一个完整路径组成：最高节点+两个分支各自的子分支最大值
一个子分支最大值：0 或 由分支节点组成的分支最大值
一个分支的最大值：最高节点+一个分支的子分支最大值

##### 125. 验证回文串

一个扩展版的验证回文串，需要处理一下下标和待比对的字符


## 2020.10.04
##### 143. 重排链表
链表操作题，感觉对指针的值是一个地址这个概念更加理解了
